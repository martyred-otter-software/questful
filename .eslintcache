[{"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\index.js":"1","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\main.js":"2","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Pathing.js":"3","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\App.js":"4","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Home.js":"5","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\FriendsList.js":"6","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Featured.js":"7","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Start.js":"8","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Account.js":"9","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\AnimatedObjects.js":"10","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Graphics.js":"11","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\EditLaunch.js":"12","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Editor.js":"13"},{"size":176,"mtime":1609616361114,"results":"14","hashOfConfig":"15"},{"size":8672,"mtime":1609709928440,"results":"16","hashOfConfig":"15"},{"size":5225,"mtime":1609706007453,"results":"17","hashOfConfig":"15"},{"size":431,"mtime":1610162248062,"results":"18","hashOfConfig":"15"},{"size":4418,"mtime":1610071412277,"results":"19","hashOfConfig":"15"},{"size":83,"mtime":1609626335738,"results":"20","hashOfConfig":"15"},{"size":85,"mtime":1609626091968,"results":"21","hashOfConfig":"15"},{"size":146,"mtime":1609715022520,"results":"22","hashOfConfig":"15"},{"size":85,"mtime":1609626145163,"results":"23","hashOfConfig":"15"},{"size":11245,"mtime":1609702056323,"results":"24","hashOfConfig":"15"},{"size":4712,"mtime":1609706876823,"results":"25","hashOfConfig":"15"},{"size":86,"mtime":1610071412267,"results":"26","hashOfConfig":"15"},{"size":2014,"mtime":1610165423002,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"dkw168",{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"30"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"30"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"30"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"52","usedDeprecatedRules":"30"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\index.js",[],["59","60"],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\main.js",["61"],"import {Enemy, Player} from './AnimatedObjects';\r\nimport {drawBG, drawHUD, BMPData2Sprite, padTilemapToFitScreen} from './Graphics';\r\nimport {computeVertices, computeEdges} from './Pathing';\r\n\r\nimport {useRef, useEffect} from 'react';\r\n\r\nexport var global = {\r\n  TILE_WIDTH: 64,\r\n  TILE_HEIGHT: 64,\r\n  PADDING_SIZE: 256,\r\n  FRAMES_PER_STEP: 3,\r\n  delay: 25,\r\n  DIRECTIONS: ['ul', 'u', 'ur', 'l', '0', 'r', 'dl', 'd', 'dr'],\r\n  AGGRO_RANGE: 1000,\r\n  ANIMATED_OBJECT_TYPES: ['player', 'orc', 'playerRangedAttack'],\r\n\r\n  canvas: null,\r\n  ctx: null,\r\n\r\n  sx: 0,\r\n  sy: 0,\r\n  viewableHeight: 0,\r\n\r\n  layoutData: null,\r\n  HUDHeight: 150,\r\n  HUDBG: null,\r\n\r\n  tileMap: null,\r\n  tileData: null,\r\n  mapWidth: null,\r\n  mapHeight: null,\r\n  numTiles: null,\r\n  tiles: null,\r\n  loadingZones: null,\r\n\r\n  vertices: null,\r\n  edges: null,\r\n  paths: null,\r\n\r\n  allAnimatedObjectData: {},\r\n  allSprites: {},\r\n\r\n  animatedObjects: null,\r\n  enemies: null,\r\n  player: null,\r\n  enemyList: null,\r\n\r\n  currentLZ: 'data/overworld.json',\r\n  x0: 128,\r\n  y0: 128,\r\n  reloadLZ: true,\r\n  gameLoop: null,\r\n\r\n  localData: true,\r\n  time: null\r\n}\r\n\r\nexport default function Main(props) {\r\n  const {callback} = props;\r\n  const canvas = useRef();\r\n\r\n  useEffect(() => {\r\n    game(canvas.current);\r\n  }, []);\r\n\r\n  return <>\r\n    <canvas ref={canvas} width={window.innerWidth} height={window.innerHeight}/>\r\n  </>\r\n}\r\n\r\nfunction game(canvas) {\r\n  global.canvas = canvas;\r\n  global.ctx = canvas.getContext('2d');\r\n  global.time = new Date();\r\n  init().then(() => {\r\n    window.setInterval(function () {\r\n      if (global.reloadLZ) {\r\n        if (global.gameLoop !== undefined && global.gameLoop !== null)\r\n          clearInterval(global.gameLoop);\r\n        loadLZ(global.currentLZ).then(() => {\r\n          global.gameLoop = window.setInterval(function () {\r\n            global.canvas.width = window.innerWidth;\r\n            global.canvas.height = window.innerHeight;\r\n            global.viewableHeight = window.innerHeight - global.HUDHeight;\r\n\r\n            for (let i = 0; i < global.enemies.length; i++) {\r\n              if (global.enemies[i].markedForDeletion)\r\n                global.enemies.splice(i--, 1);\r\n            }\r\n            for (let i = 0; i < global.animatedObjects.length; i++) {\r\n              global.animatedObjects[i].move();\r\n              if (global.animatedObjects[i].markedForDeletion)\r\n                global.animatedObjects.splice(i--, 1);\r\n            }\r\n            drawBG(global.sx, global.sy);\r\n            drawHUD(global.player);\r\n            for (let i = 0; i < global.animatedObjects.length; i++)\r\n              global.animatedObjects[i].draw();\r\n            let newTime = new Date();\r\n            global.ctx.strokeStyle = \"#FFFFFF\";\r\n            global.ctx.strokeText(1000/(newTime - global.time), 10, 10);\r\n            global.time = newTime;\r\n          }, global.delay);\r\n        });\r\n        global.reloadLZ = false;\r\n      }\r\n    }, 50);\r\n\r\n    window.addEventListener(\"keydown\", function (e) {\r\n      if (e.keyCode === 68)\r\n        global.player.dx = global.player.spd;\r\n      if (e.keyCode === 65)\r\n        global.player.dx = -global.player.spd;\r\n      if (e.keyCode === 83)\r\n        global.player.dy = global.player.spd;\r\n      if (e.keyCode === 87)\r\n        global.player.dy = -global.player.spd;\r\n    });\r\n\r\n    window.addEventListener(\"keyup\", function (e) {\r\n      if (e.keyCode === 68 && global.player.dx > 0)\r\n        global.player.dx = 0;\r\n      if (e.keyCode === 65 && global.player.dx < 0)\r\n        global.player.dx = 0;\r\n      if (e.keyCode === 83 && global.player.dy > 0)\r\n        global.player.dy = 0;\r\n      if (e.keyCode === 87 && global.player.dy < 0)\r\n        global.player.dy = 0;\r\n    });\r\n\r\n    window.addEventListener(\"mousedown\", function (e) {\r\n      global.player.attackX = e.offsetX - (global.player.x + global.player.ccx) + global.sx;\r\n      global.player.attackY = e.offsetY - (global.player.y + global.player.ccy) + global.sy;\r\n      global.player.attacking = true;\r\n    });\r\n\r\n    window.addEventListener(\"mouseup\", function (e) {\r\n      global.player.attacking = false;\r\n    });\r\n  });\r\n}\r\n\r\nasync function init() {\r\n  for (let c = 0; c < global.ANIMATED_OBJECT_TYPES.length; c++) {\r\n    let ch = global.ANIMATED_OBJECT_TYPES[c];\r\n    if (global.localData) {\r\n      global.allAnimatedObjectData[ch] = require('./data/' + ch + '.json');\r\n    } else {\r\n      await fetch(ch + '.json')\r\n        .then(response => response.json())\r\n        .then((data) => {\r\n          global.allAnimatedObjectData[ch] = data;\r\n        });\r\n    }\r\n    global.allSprites[ch] = {};\r\n    for (let id = 0; id < global.DIRECTIONS.length; id++) {\r\n      let dir = global.DIRECTIONS[id];\r\n      if (dir === '0')\r\n        continue;\r\n      let curSpriteData = global.allAnimatedObjectData[ch]['sprite'];\r\n      global.allSprites[ch][dir] = new Array(curSpriteData['data'][dir].length);\r\n      for (let fr = 0; fr < curSpriteData['data'][dir].length; fr++) {\r\n\r\n        await fetch(curSpriteData['data'][dir][fr])\r\n          .then(response => response.arrayBuffer())\r\n          .then((data) =>\r\n            global.allSprites[ch][dir][fr] = BMPData2Sprite(data, curSpriteData['width'], curSpriteData['height'])\r\n          );\r\n\r\n      }\r\n\r\n    }\r\n  }\r\n}\r\n\r\nasync function loadLZ(world) {\r\n  if (global.localData) {\r\n    global.layoutData = require('./data/layout.json');\r\n  } else {\r\n    await fetch('data/layout.json')\r\n      .then(response => response.json())\r\n      .then((data) => global.layoutData = data);\r\n  }\r\n  global.HUDHeight = global.layoutData['HUD']['height'];\r\n  global.viewableHeight = window.innerHeight - global.HUDHeight;\r\n  if (global.localData) {\r\n    await readFileData('./' + global.layoutData['HUD']['BGImg'])\r\n      .then((data) =>\r\n        global.HUDBG = BMPData2Sprite(data, window.innerWidth, global.HUDHeight)\r\n      );\r\n  } else {\r\n    await fetch('./' + global.layoutData['HUD']['BGImg'])\r\n      .then(response => response.arrayBuffer())\r\n      .then((data) =>\r\n        global.HUDBG = BMPData2Sprite(data, window.innerWidth, global.HUDHeight)\r\n      );\r\n  }\r\n  if (global.localData) {\r\n    let data = require('./' + world);\r\n    global.mapWidth = data['nx'];\r\n    global.mapHeight = data['ny'];\r\n    global.tileData = data['tiles'];\r\n    global.tileMap = data['map'];\r\n    global.numTiles = data['nTiles'];\r\n    global.enemyList = data['enemies'];\r\n    global.loadingZones = data['loadingZones'];\r\n  } else {\r\n    await fetch(world)\r\n      .then(response => response.json())\r\n      .then((data) => {\r\n        global.mapWidth = data['nx'];\r\n        global.mapHeight = data['ny'];\r\n        global.tileData = data['tiles'];\r\n        global.tileMap = data['map'];\r\n        global.numTiles = data['nTiles'];\r\n        global.enemyList = data['enemies'];\r\n        global.loadingZones = data['loadingZones'];\r\n      });\r\n  }\r\n\r\n  global.animatedObjects = [];\r\n  global.enemies = [];\r\n  global.player = new Player(global.x0, global.y0, 'player')\r\n  global.animatedObjects.push(global.player);\r\n  if (global.x0 + global.player.spriteWidth > window.innerWidth)\r\n    global.sx = Math.min(global.x0 - global.PADDING_SIZE, global.TILE_WIDTH * global.mapWidth - window.innerWidth);\r\n  else\r\n    global.sx = 0;\r\n  if (global.y0 + global.player.spriteHeight > global.viewableHeight)\r\n    global.sy = Math.min(global.y0 - global.PADDING_SIZE, global.TILE_HEIGHT * global.mapHeight - global.viewableHeight);\r\n  else\r\n    global.sy = 0;\r\n  for (let i = 0; i < global.enemyList.length; i++) {\r\n    global.animatedObjects.push(new Enemy(global.enemyList[i]['x0'], global.enemyList[i]['y0'], global.enemyList[i]['type']));\r\n    global.enemies.push(global.animatedObjects[global.animatedObjects.length - 1]);\r\n  }\r\n  global.tiles = new Array(global.numTiles);\r\n  for (let tIdx = 0; tIdx < global.numTiles; tIdx++) {\r\n    await fetch(global.tileData[tIdx]['data'])\r\n      .then(response => response.arrayBuffer())\r\n      .then((data) =>\r\n        global.tiles[tIdx] = BMPData2Sprite(data, global.TILE_WIDTH, global.TILE_HEIGHT)\r\n      );\r\n  }\r\n  global.tileMap = padTilemapToFitScreen(global.tileMap);\r\n  global.mapWidth = global.tileMap[0].length;\r\n  global.mapHeight = global.tileMap.length;\r\n\r\n  global.vertices = computeVertices();\r\n  global.edges = computeEdges(global.vertices);\r\n\r\n}\r\n\r\nfunction readFileData(filename) {\r\n  const file = new File([\"\"], filename);\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n\r\n    reader.onload = (event) => {\r\n      resolve(event.target.result);\r\n      console.log('ok');\r\n    };\r\n\r\n    reader.onerror = (err) => {\r\n      reject(err);\r\n    };\r\n\r\n    reader.readAsArrayBuffer(file)\r\n  });\r\n}","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Pathing.js",["62"],"import { global } from './main'\r\n\r\nexport class Vertex {\r\n  constructor(x, y, dx, dy) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.dx = dx;\r\n    this.dy = dy;\r\n  }\r\n\r\n  isEdge(otherV) {\r\n    if (distance(this.x, this.y, otherV.x, otherV.y) >= global.AGGRO_RANGE)\r\n      return false;\r\n\r\n\r\n    if (otherV.x - this.x === 0) {\r\n      let start1X = this.x + 1\r\n      let start1Y = this.y;\r\n      let end1X = otherV.x + 1;\r\n      let end1Y = otherV.y;\r\n\r\n      let start2X = this.x - 1;\r\n      let start2Y = this.y;\r\n      let end2X = otherV.x - 1;\r\n      let end2Y = otherV.y;\r\n      return isLineOfSight(start1X, start1Y, end1X, end1Y) || isLineOfSight(start2X, start2Y, end2X, end2Y);\r\n    } else if (otherV.y - this.y === 0) {\r\n      let start1X = this.x;\r\n      let start1Y = this.y + 1;\r\n      let end1X = otherV.x;\r\n      let end1Y = otherV.y + 1;\r\n\r\n      let start2X = this.x;\r\n      let start2Y = this.y - 1;\r\n      let end2X = otherV.x;\r\n      let end2Y = otherV.y - 1;\r\n      return isLineOfSight(start1X, start1Y, end1X, end1Y) || isLineOfSight(start2X, start2Y, end2X, end2Y);\r\n    } else\r\n      return isLineOfSight(this.x + this.dx, this.y + this.dy, otherV.x + otherV.dx, otherV.y + otherV.dy);\r\n  }\r\n\r\n}\r\n\r\nexport class Edge {\r\n  constructor(v1, v2) {\r\n    this.v1 = v1;\r\n    this.v2 = v2;\r\n    this.distance = distance(v1.x, v1.y, v2.x, v2.y);\r\n  }\r\n\r\n}\r\n\r\nclass ShortestPathSet {\r\n  constructor(v) {\r\n    this.v = v;\r\n\r\n    //Dijkstra's algorithm\r\n  }\r\n\r\n  contains(v) {\r\n    return this.v.x === v.x && this.v.y === v.y;\r\n  }\r\n}\r\n\r\nexport function distance(x1, y1, x2, y2) {\r\n  return norm(x2 - x1, y2 - y1);\r\n}\r\n\r\nexport function norm(x, y) {\r\n  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n}\r\n\r\nexport function computeVertices() {\r\n  let result = [];\r\n  for (let i = 1; i < global.mapWidth; i++) {\r\n    for (let j = 1; j < global.mapHeight; j++) {\r\n      if ((+global.tileData[global.tileMap[j][i]]['passable']) + (+global.tileData[global.tileMap[j - 1][i]]['passable'])\r\n        + (+global.tileData[global.tileMap[j][i - 1]]['passable']) + (+global.tileData[global.tileMap[j - 1][i - 1]]['passable']) === 3) {\r\n        let dx;\r\n        let dy;\r\n        if (!global.tileData[global.tileMap[j][i - 1]]['passable'] || !global.tileData[global.tileMap[j - 1][i - 1]]['passable'])\r\n          dx = 1;\r\n        else\r\n          dx = -1;\r\n        if (!global.tileData[global.tileMap[j - 1][i]]['passable'] || !global.tileData[global.tileMap[j - 1][i - 1]]['passable'])\r\n          dy = 1;\r\n        else\r\n          dy = -1;\r\n        result.push(new Vertex(global.TILE_WIDTH * i, global.TILE_HEIGHT * j, dx, dy));\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function computeEdges(v) {\r\n  let result = [];\r\n  for (let i = 0; i < v.length; i++) {\r\n    for (let j = i + 1; j < v.length; j++) {\r\n      if (v[i].isEdge(v[j]))\r\n        result.push(new Edge(v[i], v[j]));\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction isLineOfSight(x1, y1, x2, y2) {    // check if line is a line-of-sight\r\n  let ix1 = Math.floor(x1 / global.TILE_WIDTH);\r\n  let iy1 = Math.floor(y1 / global.TILE_HEIGHT);\r\n  let ix2 = Math.floor(x2 / global.TILE_WIDTH);\r\n  let iy2 = Math.floor(y2 / global.TILE_HEIGHT);\r\n  if (!global.tileData[global.tileMap[iy1][ix1]]['passable'])\r\n    return false;\r\n  if (ix1 === ix2 && iy1 === iy2)\r\n    return true;\r\n  else {\r\n    if (ix1 === ix2)      // special cases to avoid dividing by zero\r\n      return isLineOfSight(x1, global.TILE_HEIGHT * (iy1 + Math.sign(y2 - y1)), x2, y2);\r\n    else if (iy1 === iy2) // \"\r\n      return isLineOfSight(global.TILE_WIDTH * (ix1 + Math.sign(x2 - x1)), y1, x2, y2);\r\n    else {\r\n      let ixChange;\r\n      let iyChange;\r\n      let slope = (y2 - y1) / (x2 - x1);\r\n      if (x1 % global.TILE_WIDTH === 0)\r\n        ixChange = Math.sign(x2 - x1);\r\n      else\r\n        ixChange = 0.5 + 0.5 * Math.sign(x2 - x1);\r\n      if (y1 % global.TILE_HEIGHT === 0)\r\n        iyChange = Math.sign(y2 - y1);\r\n      else\r\n        iyChange = 0.5 + 0.5 * Math.sign(y2 - y1);\r\n      if (ix1 + ixChange === ix2 && iy1 + iyChange === iy2)\r\n        return true;\r\n      if (y1 + slope * (global.TILE_WIDTH * (ixChange + ix1) - x1) >= iy1 * global.TILE_HEIGHT\r\n        && y1 + slope * (global.TILE_WIDTH * (ixChange + ix1) - x1) < (iy1 + 1) * global.TILE_HEIGHT) {\r\n        let x1New = global.TILE_WIDTH * (ix1 + ixChange);\r\n        if (ixChange < 0)\r\n          x1New += global.TILE_WIDTH - 1;\r\n        let y1New = y1 + slope * (x1New - x1);\r\n        return isLineOfSight(x1New, y1New, x2, y2);\r\n      } else {\r\n        let y1New = global.TILE_HEIGHT * (iy1 + iyChange);\r\n        if (iyChange < 0)\r\n          y1New += global.TILE_HEIGHT - 1;\r\n        let x1New = x1 + (y1New - y1) / slope;\r\n        return isLineOfSight(x1New, y1New, x2, y2);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function collisionOk(x, y, mask) {\r\n  let result = true;\r\n  for (let u = 0; u < mask.length; u++) {\r\n    for (let v = 0; v < mask[u].length; v++) {\r\n      let ix = Math.floor((x + u) / global.TILE_WIDTH);\r\n      let iy = Math.floor((y + v) / global.TILE_HEIGHT);\r\n      if (mask[v][u] !== 0 && global.tileData[global.tileMap[iy][ix]]['passable'] === false)\r\n        result = false;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\App.js",["63"],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Home.js",["64","65"],"import {useState} from 'react';\r\nimport {useEffect} from 'react';\r\nimport {useRef} from 'react';\r\nimport Featured from \"./Featured\";\r\nimport Start from \"./Start\";\r\nimport EditLaunch from \"./EditLaunch\";\r\nimport FriendsList from \"./FriendsList\";\r\nimport Account from \"./Account\";\r\n\r\nfunction Home(props) {\r\n  const [selectedId, setSelectedId] = useState(\"featured\");\r\n  const thisComponent = useRef();\r\n  return (\r\n    <div ref={thisComponent} className=\"home\">\r\n      <div><Banner /></div>\r\n      <div className=\"homeContent\"><TabColumn callback={(id) => setSelectedId(id)} /><ContentPane callback={props.callback} parentSelectedId={selectedId} /></div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Home;\r\n\r\nfunction Banner() {\r\n  const canvas = useRef();\r\n  useEffect(() => {\r\n    const ctx = canvas.current.getContext('2d');\r\n    ctx.fillStyle = \"green\";\r\n    ctx.fillRect(0,0, canvas.current.width, canvas.current.height);\r\n  });\r\n  return <div className=\"banner\"><canvas ref={canvas} width={window.innerWidth} height={0.2*window.innerHeight}/></div>\r\n}\r\n\r\nfunction TabColumn(props) {\r\n  const tabList = [\r\n    {\r\n      text: \"Featured Content\",\r\n      contentId: \"featured\"\r\n    },\r\n    {\r\n      text: \"Start a Quest\",\r\n      contentId: \"start\"\r\n    },\r\n    {\r\n      text: \"Build a Quest\",\r\n      contentId: \"build\"\r\n    },\r\n    {\r\n      text: \"Friends\",\r\n      contentId: \"friends\"\r\n    },\r\n    {\r\n      text: \"Account\",\r\n      contentId: \"account\"\r\n    }\r\n  ];\r\n\r\n  const [selectedId, setSelectedId] = useState(\"featured\");\r\n  const childWasClicked = (childId) => {\r\n    setSelectedId(childId);\r\n    props.callback(childId);\r\n  };\r\n  const thisComponent = useRef();\r\n\r\n  return <div ref={thisComponent} className=\"tabColumn\"> {\r\n      tabList.map((tabData) =>\r\n        <Tab key={tabData.contentId} id={tabData.contentId} parent={thisComponent} text={tabData.text} callback={childWasClicked} selected={selectedId === tabData.contentId} />)\r\n    } </div>\r\n}\r\n\r\nfunction Tab(props) {\r\n  const [selected, setSelected] = useState(props.selected);\r\n  const [hovered, setHovered] = useState(false);\r\n  const thisComponent = useRef();\r\n  const canvas = useRef();\r\n\r\n  const clickHandler = (e) => {\r\n    if (thisComponent.current.contains(e.target)) {\r\n      setSelected(true);\r\n      props.callback(props.id);\r\n    } else if (props.parent.current.contains(e.target))\r\n      setSelected(false);\r\n  };\r\n\r\n  const mouseMoveHandler = (e) => {\r\n    if (thisComponent.current.contains(e.target))\r\n      setHovered(true);\r\n    else\r\n      setHovered(false);\r\n  };\r\n\r\n  useEffect(() => {\r\n    document.addEventListener('mousemove', mouseMoveHandler);\r\n    document.addEventListener('click', clickHandler);\r\n    return () => {\r\n      document.removeEventListener('mousemove', mouseMoveHandler);\r\n      document.removeEventListener('click', clickHandler);\r\n    }\r\n  }, []);\r\n  useEffect(() => {\r\n    const ctx = canvas.current.getContext('2d');\r\n    if (selected) {\r\n      ctx.fillStyle = \"#000011\";\r\n      ctx.fillRect(0,0,canvas.current.width, canvas.current.height);\r\n\r\n      ctx.font = \"25px Segoe UI\";\r\n      ctx.fillStyle = \"#BBBBDD\";\r\n      ctx.fillText(props.text, 20, canvas.current.height / 2 + 10);\r\n    } else if (hovered) {\r\n      ctx.fillStyle = \"#8888AA\";\r\n      ctx.fillRect(0,0,canvas.current.width, canvas.current.height);\r\n\r\n      ctx.font = \"30px Segoe UI\";\r\n      ctx.fillStyle = \"#332200\";\r\n      ctx.fillText(props.text, 30 - props.text.length * 5 / 3, canvas.current.height / 2 + 6);\r\n    } else {\r\n      ctx.fillStyle = \"#BBBBFF\";\r\n      ctx.fillRect(0,0,canvas.current.width, canvas.current.height);\r\n\r\n      ctx.font = \"25px Segoe UI\";\r\n      ctx.fillStyle = \"#332200\";\r\n      ctx.fillText(props.text, 20, canvas.current.height / 2 + 10);\r\n    }\r\n  }, [selected, hovered])\r\n  return <div ref={thisComponent}  className=\"tab\"><canvas ref={canvas} width={0.15 * window.innerWidth} height={0.8 * 0.2 * window.innerHeight} /></div>\r\n}\r\n\r\nfunction ContentPane(props) {\r\n  const [selectedId, setSelectedId] = useState(\"featured\");\r\n  useEffect(() => setSelectedId(props.parentSelectedId), [props.parentSelectedId]);\r\n  return <div className=\"contentPane\">{\r\n    selectedId === 'featured' ? <Featured />\r\n      : selectedId === 'start' ? <Start callback={props.callback} />\r\n      : selectedId === 'build' ? <EditLaunch />\r\n        : selectedId === 'friends' ? <FriendsList />\r\n          : <Account />\r\n  }</div>;\r\n}","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\FriendsList.js",[],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Featured.js",[],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Start.js",[],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Account.js",[],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\AnimatedObjects.js",["66"],"import { norm, distance, collisionOk } from './Pathing';\r\nimport { drawSprite } from './Graphics';\r\nimport { global } from './main';\r\n\r\nclass AnimatedObject {\r\n  constructor(x, y, type) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.dx = 0;\r\n    this.dy = 0;\r\n    this.sprites = global.allSprites[type];\r\n    this.spd = global.allAnimatedObjectData[type]['speed'];\r\n    this.ccx = global.allAnimatedObjectData[type]['collisionCenter'][0];\r\n    this.ccy = global.allAnimatedObjectData[type]['collisionCenter'][1];\r\n    this.markedForDeletion = false;\r\n  }\r\n}\r\n\r\nexport class Projectile extends AnimatedObject {\r\n  constructor(x, y, dx, dy, type) {\r\n    super(x, y, type);\r\n    this.travelAngle = Math.acos(dx / norm(dx, dy));\r\n    this.hx = global.allAnimatedObjectData[type]['projectileLength'] / 2 * dx / norm(dx, dy);\r\n    this.hy = global.allAnimatedObjectData[type]['projectileLength'] / 2 * dy / norm(dx, dy);\r\n    this.dx = this.spd * dx / norm(dx, dy);\r\n    this.dy = this.spd * dy / norm(dx, dy);\r\n    if (dy < 0)\r\n      this.travelAngle = 2 * Math.PI - this.travelAngle;\r\n    let tempArray = ['r', 'dr', 'd', 'dl', 'l', 'ul', 'u', 'ur','r'];\r\n    this.dir = tempArray[Math.round(this.travelAngle * 4 / Math.PI)];\r\n  }\r\n\r\n  move() {\r\n    if (this.markedForDeletion)\r\n      return;\r\n    this.x += this.dx;\r\n    this.y += this.dy;\r\n    let hix = Math.floor((this.x + this.ccx + this.hx) / global.TILE_WIDTH);\r\n    let hiy = Math.floor((this.y + this.ccy + this.hy) / global.TILE_HEIGHT);\r\n    if (!global.tileData[global.tileMap[hiy][hix]]['passable']) {\r\n      this.markedForDeletion = true;\r\n      return;\r\n    }\r\n    for (let i = 0; i < global.enemies.length; i++) {\r\n      let e = global.enemies[i];\r\n      let hsx = this.x + this.ccx + this.hx - e.x;\r\n      let hsy = this.y + this.ccy + this.hy - e.y;\r\n      if (hsx >= 0 && hsx < e.spriteWidth && hsy >= 0 && hsy < e.spriteHeight){\r\n        if (e.sprites[e.dir][Math.floor(e.stepCounter / global.FRAMES_PER_STEP)].data[4 * (hsx + hsy * e.spriteWidth) + 3] !== 0) {\r\n          this.markedForDeletion = true;\r\n          e.HP -= global.player.attackDamage;\r\n          if (e.HP <= 0)\r\n            e.markedForDeletion = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  draw() {\r\n    if (!this.markedForDeletion) {\r\n      drawSprite(this.x, this.y, global.sx, global.sy, this.sprites[this.dir][0]);\r\n    }\r\n  }\r\n}\r\n\r\nclass Character extends AnimatedObject {\r\n  constructor(x, y, type) {\r\n    super(x, y, type);\r\n    this.stands = global.allAnimatedObjectData[type]['sprite']['stands'];\r\n    this.nRunFrames = global.allAnimatedObjectData[type]['sprite']['nRunFrames'];\r\n    this.collisionMask = global.allAnimatedObjectData[type]['collisionMask'];\r\n    this.spriteWidth = global.allAnimatedObjectData[type]['sprite']['width'];\r\n    this.spriteHeight = global.allAnimatedObjectData[type]['sprite']['height'];\r\n    this.stepCounter = 0;\r\n    this.attacking = false;\r\n    this.attackX = 0;\r\n    this.attackY = 0;\r\n    this.dir = 'd';\r\n  }\r\n\r\n  move() {  // needs to be overridden by child class\r\n    let dir = global.DIRECTIONS[4 + this.dx / this.spd + 3 * this.dy / this.spd];\r\n    if (dir !== '0') {\r\n      this.dir = dir;\r\n      this.stepCounter++;\r\n      this.stepCounter %= this.nRunFrames * global.FRAMES_PER_STEP;\r\n    }\r\n  }\r\n\r\n  draw() {\r\n    if (this.stands && this.dx === 0 && this.dy === 0)\r\n      drawSprite(this.x, this.y, global.sx, global.sy, this.sprites[this.dir][this.nRunFrames])\r\n    else\r\n      drawSprite(this.x, this.y, global.sx, global.sy, this.sprites[this.dir][Math.floor(this.stepCounter / global.FRAMES_PER_STEP)])\r\n  }\r\n}\r\n\r\nexport class Player extends Character {\r\n  constructor(x, y, type) {\r\n    super(x, y, type);\r\n    this.attackDamage = global.allAnimatedObjectData[type]['attackDamage'];\r\n    this.attackRange = global.allAnimatedObjectData[type]['attackRange'];\r\n    this.attackArc = global.allAnimatedObjectData[type]['attackArcDeg'] * Math.PI / 180;\r\n    this.rx = global.allAnimatedObjectData[type]['rangedAttackOrigin'][0];\r\n    this.ry = global.allAnimatedObjectData[type]['rangedAttackOrigin'][1];\r\n    this.attackTimer = 0;\r\n    this.attackDelay = 5;\r\n    this.attackType = 'ranged';\r\n    this.maxHP = global.allAnimatedObjectData[type]['maxHP'];\r\n    this.HP = 0.8 * this.maxHP;\r\n  }\r\n\r\n  move() {\r\n    super.move();\r\n    if (this.attacking)\r\n      this.attack();\r\n    this.attackTimer++;\r\n    let deltaX = this.dx;\r\n    while (!collisionOk(this.x + deltaX, this.y, this.collisionMask) && deltaX !== 0) {\r\n      deltaX -= Math.sign(deltaX);\r\n    }\r\n    this.x += deltaX;\r\n    let cx = this.x - global.sx;\r\n    if (cx < global.PADDING_SIZE && deltaX < 0) {\r\n      global.sx += deltaX;\r\n      if (global.sx < 0) {\r\n        this.x -= (deltaX - global.sx);\r\n        global.sx = 0;\r\n      }\r\n    }\r\n    if (cx + this.spriteWidth + global.PADDING_SIZE > window.innerWidth && deltaX > 0) {\r\n      global.sx += deltaX;\r\n      if (global.sx >global. TILE_WIDTH * global.mapWidth - window.innerWidth) {\r\n        this.x -= deltaX - (global.sx - (global.TILE_WIDTH * global.mapWidth - window.innerWidth));\r\n        global.sx = global.TILE_WIDTH * global.mapWidth - window.innerWidth;\r\n      }\r\n    }\r\n    let deltaY = this.dy;\r\n    while (!collisionOk(this.x, this.y + deltaY, this.collisionMask) && deltaY !== 0) {\r\n      deltaY -= Math.sign(deltaY);\r\n    }\r\n\r\n    this.y += deltaY;\r\n    let cy = this.y - global.sy;\r\n    if (cy < global.PADDING_SIZE && deltaY < 0) {\r\n      global.sy += deltaY;\r\n      if (global.sy < 0) {\r\n        this.y -= (deltaY - global.sy);\r\n        global.sy = 0;\r\n      }\r\n    }\r\n    if (cy + this.spriteHeight + global.PADDING_SIZE > global.viewableHeight && deltaY > 0) {\r\n      global.sy += deltaY;\r\n      if (global.sy > global.TILE_HEIGHT * global.mapHeight - global.viewableHeight) {\r\n        this.y -= deltaY - (global.sy - (global.TILE_HEIGHT * global.mapHeight - global.viewableHeight));\r\n        global.sy = global.TILE_HEIGHT * global.mapHeight - global.viewableHeight;\r\n      }\r\n    }\r\n    for (let i = 0; i < global.loadingZones.length; i++) {\r\n      var ix = Math.floor((global.player.x + global.player.ccx) / global.TILE_WIDTH);\r\n      var iy = Math.floor((global.player.y + global.player.ccy) / global.TILE_HEIGHT);\r\n      if (ix === global.loadingZones[i]['ix'] && iy === global.loadingZones[i]['iy']) {\r\n        global.x0 = global.loadingZones[i]['x0'];\r\n        global.y0 = global.loadingZones[i]['y0'];\r\n        global.reloadLZ = true;\r\n        global.currentLZ = global.loadingZones[i]['destination'];\r\n      }\r\n    }\r\n  }\r\n\r\n  draw() {\r\n    let sprite = global.ctx.createImageData(this.spriteWidth, this.spriteHeight);\r\n    for (let i = 0; i < 4 * this.spriteWidth * this.spriteHeight; i++) {\r\n      if (this.stands && this.dx === 0 && this.dy === 0) {\r\n        sprite.data[i] = this.sprites[this.dir][this.nRunFrames].data[i];\r\n      } else {\r\n        sprite.data[i] = this.sprites[this.dir][Math.floor(this.stepCounter / global.FRAMES_PER_STEP)].data[i];\r\n      }\r\n      if (this.attacking) {\r\n        if (sprite.data[4 * Math.floor(i / 4) + 3] !== 0) {\r\n          sprite.data[4 * Math.floor(i / 4)] = 255;\r\n        }\r\n      }\r\n    }\r\n    drawSprite(this.x, this.y, global.sx, global.sy, sprite);\r\n  }\r\n\r\n  attack() {\r\n    if (this.attackTimer < this.attackDelay)\r\n      return;\r\n    this.attackTimer = 0;\r\n    if (this.attackType === 'melee')\r\n      this.meleeAttack();\r\n    else if (this.attackType === 'ranged')\r\n      this.rangedAttack();\r\n  }\r\n\r\n  meleeAttack() {\r\n    for (let i = 0; i < global.enemies.length; i++) {\r\n      let enemy = global.enemies[i];\r\n      let sepX = enemy.x + enemy.ccx - (this.x + this.ccx);\r\n      let sepY = enemy.y + enemy.ccy - (this.y + this.ccy);\r\n      let dist = distance(this.x + this.ccx, this.y + this.ccy, enemy.x + enemy.ccx, enemy.y + enemy.ccy)\r\n      let attackInRange = true;\r\n      if (dist >= this.attackRange)\r\n        attackInRange = false;\r\n      let attackAngle = Math.acos((this.attackX - this.x - this.ccx) / dist);\r\n      if (this.attackY - this.y - this.ccy < 0)\r\n        attackAngle = 2 * Math.PI - attackAngle;\r\n      let theta1 = attackAngle - this.attackArc / 2;\r\n      let theta2 = attackAngle + this.attackArc / 2;\r\n      let theta = Math.acos(sepX / dist);\r\n      if (sepY < 0)\r\n        theta = 2 * Math.PI - theta;\r\n      if (theta1 < 0 && theta > Math.PI) {\r\n        theta1 += 2 * Math.PI;\r\n        theta2 += 2 * Math.PI;\r\n      }\r\n      if (theta2 > 2 * Math.PI && theta < Math.PI) {\r\n        theta1 -= 2 * Math.PI;\r\n        theta2 -= 2 * Math.PI;\r\n      }\r\n      if (theta > theta2 || theta < theta1)\r\n        attackInRange = false;\r\n      if (attackInRange) {\r\n        enemy.HP -= this.attackDamage;\r\n        if (enemy.HP <= 0)\r\n          enemy.markedForDeletion = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  rangedAttack(){\r\n    global.animatedObjects.push(new Projectile(this.x + this.rx, this.y + this.ry, this.attackX, this.attackY, 'playerRangedAttack'));\r\n  }\r\n}\r\n\r\nexport class Enemy extends Character {\r\n  constructor(x, y, type) {\r\n    super(x, y, type);\r\n    this.maxHP = global.allAnimatedObjectData[type]['maxHP'];\r\n    this.HP = this.maxHP;\r\n    this.HPBarCenter = global.allAnimatedObjectData[type]['sprite']['HPBarCenter'];\r\n    this.HPBarWidth = global.allAnimatedObjectData[type]['sprite']['HPBarWidth'];\r\n  }\r\n\r\n  move() {\r\n    super.move();\r\n    if (this.markedForDeletion)\r\n      return;\r\n    if (distance(this.x, this.y, global.player.x, global.player.y) < global.AGGRO_RANGE) {\r\n      this.dx = Math.min(this.spd, Math.abs(global.player.x - this.x)) * Math.sign(global.player.x - this.x);\r\n      this.dy = Math.min(this.spd, Math.abs(global.player.y - this.y)) * Math.sign(global.player.y - this.y);\r\n    } else {\r\n      this.dx = 0;\r\n      this.dy = 0;\r\n      return;\r\n    }\r\n    let deltaX = this.dx;\r\n    while (!collisionOk(this.x + deltaX, this.y, this.collisionMask) && deltaX !== 0) {\r\n      deltaX -= Math.sign(deltaX);\r\n    }\r\n    this.x += deltaX;\r\n\r\n    let deltaY = this.dy;\r\n    while (!collisionOk(this.x, this.y + deltaY, this.collisionMask) && deltaY !== 0) {\r\n      deltaY -= Math.sign(deltaY);\r\n    }\r\n    this.y += deltaY;\r\n    super.move();\r\n  }\r\n\r\n  draw() {\r\n    if (this.markedForDeletion)\r\n      return;\r\n    let currentSprite;\r\n    if (this.stands && this.dx === 0 && this.dy === 0)\r\n      currentSprite = this.sprites[this.dir][this.nRunFrames];\r\n    else\r\n      currentSprite = this.sprites[this.dir][Math.floor(this.stepCounter / global.FRAMES_PER_STEP)];\r\n    for (let i = 0; i < this.HPBarWidth; i++) {\r\n      let c = this.HPBarCenter - this.HPBarWidth / 2 + i;\r\n      for (let j = 0; j < 5; j++) {\r\n        if (this.HP / this.maxHP > i / this.HPBarWidth) {\r\n          currentSprite.data[4 * (this.spriteWidth * j + c)] = 0;\r\n          currentSprite.data[4 * (this.spriteWidth * j + c) + 1] = 255;\r\n        } else {\r\n          currentSprite.data[4 * (this.spriteWidth * j + c)] = 255;\r\n          currentSprite.data[4 * (this.spriteWidth * j + c) + 1] = 0;\r\n        }\r\n        currentSprite.data[4 * (this.spriteWidth * j + c) + 2] = 0;\r\n        currentSprite.data[4 * (this.spriteWidth * j + c) + 3] = 255;\r\n      }\r\n    }\r\n    drawSprite(this.x, this.y, global.sx, global.sy, currentSprite);\r\n  }\r\n}\r\n","C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Graphics.js",[],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\EditLaunch.js",[],"C:\\Users\\Jonathan Martin\\IdeaProjects\\questful\\src\\Editor.js",["67","68"],{"ruleId":"69","replacedBy":"70"},{"ruleId":"71","replacedBy":"72"},{"ruleId":"73","severity":1,"message":"74","line":59,"column":10,"nodeType":"75","messageId":"76","endLine":59,"endColumn":18},{"ruleId":"73","severity":1,"message":"77","line":53,"column":7,"nodeType":"75","messageId":"76","endLine":53,"endColumn":22},{"ruleId":"73","severity":1,"message":"78","line":5,"column":9,"nodeType":"75","messageId":"76","endLine":5,"endColumn":18},{"ruleId":"79","severity":1,"message":"80","line":98,"column":6,"nodeType":"81","endLine":98,"endColumn":8,"suggestions":"82"},{"ruleId":"79","severity":1,"message":"83","line":123,"column":6,"nodeType":"81","endLine":123,"endColumn":25,"suggestions":"84"},{"ruleId":"85","severity":1,"message":"86","line":133,"column":22,"nodeType":"87","messageId":"88","endLine":133,"endColumn":40,"fix":"89"},{"ruleId":"79","severity":1,"message":"90","line":38,"column":6,"nodeType":"81","endLine":38,"endColumn":8,"suggestions":"91"},{"ruleId":"79","severity":1,"message":"92","line":52,"column":6,"nodeType":"81","endLine":52,"endColumn":8,"suggestions":"93"},"no-native-reassign",["94"],"no-negated-in-lhs",["95"],"no-unused-vars","'callback' is assigned a value but never used.","Identifier","unusedVar","'ShortestPathSet' is defined but never used.","'useEffect' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'clickHandler'. Either include it or remove the dependency array.","ArrayExpression",["96"],"React Hook useEffect has a missing dependency: 'props.text'. Either include it or remove the dependency array.",["97"],"no-whitespace-before-property","Unexpected whitespace before property TILE_WIDTH.","MemberExpression","unexpectedWhitespace",{"range":"98","text":"99"},"React Hook useEffect has a missing dependency: 'cellArray'. Either include it or remove the dependency array.",["100"],"React Hook useEffect has missing dependencies: 'loc' and 'populate'. Either include them or remove the dependency array. If 'populate' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["101"],"no-global-assign","no-unsafe-negation",{"desc":"102","fix":"103"},{"desc":"104","fix":"105"},[4933,4935],".",{"desc":"106","fix":"107"},{"desc":"108","fix":"109"},"Update the dependencies array to be: [clickHandler]",{"range":"110","text":"111"},"Update the dependencies array to be: [selected, hovered, props.text]",{"range":"112","text":"113"},"Update the dependencies array to be: [cellArray]",{"range":"114","text":"115"},"Update the dependencies array to be: [loc, populate]",{"range":"116","text":"117"},[2851,2853],"[clickHandler]",[3761,3780],"[selected, hovered, props.text]",[1126,1128],"[cellArray]",[1642,1644],"[loc, populate]"]